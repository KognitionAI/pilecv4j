/*
 * Copyright 2022 Jim Carroll
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ai.kognition.pilecv4j.tracking;

import static ai.kognition.pilecv4j.image.CvMat.TRACK_MEMORY_LEAKS;

import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.StringJoiner;

import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.video.KalmanFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ai.kognition.pilecv4j.image.CvMat;
import ai.kognition.pilecv4j.image.CvRaster.Closer;
import ai.kognition.pilecv4j.image.Utils;

/**
 * This represents a standard Kalman filter. The transition, control, and measurement matrices can be modified ({@link CvKalmanFilter#setTransitionMatrix(Mat)},
 * {@link CvKalmanFilter#setControlMatrix(Mat)}, {@link CvKalmanFilter#setMeasurementMatrix(Mat)}, respectively) to get extended functionality.
 *
 * @see <a href="https://en.wikipedia.org/wiki/Kalman_filter">wikipedia: Kalman filter</a>
 */
public class CvKalmanFilter extends KalmanFilter implements AutoCloseable {
    private static final Logger LOGGER = LoggerFactory.getLogger(CvKalmanFilter.class);

    private static final Method nativeDelete;
    protected boolean deletedAlready = false;
    protected boolean skipOnceForDelete = false;

    protected final RuntimeException initTrace;
    protected RuntimeException deleteTrace = null;

    public final int dynamicParameters;
    public final int measureParameters;
    public final int controlParameters;
    public final KalmanDataType dataType;

    static {
        CvMat.initOpenCv();

        try {
            nativeDelete = KalmanFilter.class.getDeclaredMethod("delete", long.class);
            nativeDelete.setAccessible(true);
        } catch(final NoSuchMethodException | SecurityException e) {
            throw new RuntimeException("Got an exception trying to access " + KalmanFilter.class.getSimpleName() +
                ".delete. Either the security model is too restrictive or the version of OpenCv can't be supported.", e);
        }
    }

    public enum KalmanDataType {
        CV_32F(CvType.CV_32F, float.class), CV_64F(CvType.CV_64F, double.class);

        public final int cvType;
        public final Class<? extends Number> javaType;

        KalmanDataType(final int cvType, final Class<? extends Number> javaType) {
            this.cvType = cvType;
            this.javaType = javaType;
        }
    }

    public CvKalmanFilter(final int dynamicParameters, final int measureParameters, final KalmanDataType type) {
        this(dynamicParameters, measureParameters, 0, type);
    }

    /**
     * TODO change this to a builder pattern.
     *
     * @param dynamicParameters Dimensionality of the state. Must be greater than 0.
     * @param measureParameters Dimensionality of the measurement. Must be greater than 0.
     * @param controlParameters Dimensionality of the control vector. Default value is 0.
     * @param type Numerical primitive type underlying all {@link Mat} generated by the Kalman Filter.
     */
    public CvKalmanFilter(final int dynamicParameters, final int measureParameters, final int controlParameters, final KalmanDataType type) {
        super(dynamicParameters, measureParameters, controlParameters, type.cvType);
        this.dynamicParameters = dynamicParameters;
        this.measureParameters = measureParameters;
        this.controlParameters = controlParameters;
        this.dataType = type;
        initTrace = TRACK_MEMORY_LEAKS ? new RuntimeException("Here's where I was instantiated: ") : null;
    }

    /**
     * Updates the predicted state from the measurement and returns the posteriori state (as in {@link CvKalmanFilter#getCorrectedState()}).
     *
     * @return a new mat to be managed by the caller.
     *
     * @see CvKalmanFilter#getCorrectedState()
     */
    @Override
    public CvMat correct(final Mat measurement) {
        return CvMat.move(super.correct(measurement));
    }

    /**
     * @return a shallow copied Mat to be managed by the caller.
     */
    @Override
    public CvMat predict(final Mat control) {
        return CvMat.move(super.predict(control));
    }

    /**
     * @return a shallow copied Mat to be managed by the caller.
     */
    @Override
    public CvMat predict() {
        return CvMat.move(super.predict());
    }

    @Override
    public CvMat get_statePre() {
        return CvMat.move(super.get_statePre());
    }

    /**
     * Predicted state: (x'(k)): x(k)=A*x(k-1)+B*u(k)
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getPredictionState() {
        return this.get_statePre();
    }

    public CvKalmanFilter setPredictionState(final Mat matrix) {
        if(notAllowSet(getPredictionState(), matrix))
            throw new ArithmeticException("Cannot set prediction state: wrong size.");
        super.set_statePre(matrix);
        return this;
    }

    @Override
    public CvMat get_statePost() {
        return CvMat.move(super.get_statePost());
    }

    /**
     * Corrected state: (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getCorrectedState() {
        return this.get_statePost();
    }

    /**
     * @param matrix a Mat of size [{@link CvKalmanFilter#dynamicParameters},1].
     */
    public CvKalmanFilter setCorrectedState(final Mat matrix) {
        if(notAllowSet(getCorrectedState(), matrix))
            throw new ArithmeticException("Cannot set corrected state: wrong size.");
        super.set_statePost(matrix);
        return this;
    }

    @Override
    public CvMat get_transitionMatrix() {
        return CvMat.move(super.get_transitionMatrix());
    }

    /**
     * State transition matrix: (A)
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getTransitionMatrix() {
        return get_transitionMatrix();
    }

    public CvKalmanFilter setTransitionMatrix(final Mat transitionMatrix) {
        if(notAllowSet(getTransitionMatrix(), transitionMatrix))
            throw new ArithmeticException("Cannot set transition matrix: wrong size.");
        super.set_transitionMatrix(transitionMatrix);
        return this;
    }

    @Override
    public CvMat get_controlMatrix() {
        return CvMat.move(super.get_controlMatrix());
    }

    /**
     * Control matrix (B)
     * <p>
     * Unused if there is no control.
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getControlMatrix() {
        return this.get_controlMatrix();
    }

    public CvKalmanFilter setControlMatrix(final Mat controlMatrix) {
        if(controlParameters <= 0)
            throw new ArithmeticException("Cannot set control: no control parameters.");
        if(notAllowSet(getControlMatrix(), controlMatrix))
            throw new ArithmeticException("Cannot set control: wrong size.");
        super.set_controlMatrix(controlMatrix);
        return this;
    }

    @Override
    public CvMat get_measurementMatrix() {
        return CvMat.move(super.get_measurementMatrix());
    }

    /**
     * Measurement matrix (H)
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getMeasurementMatrix() {
        return get_measurementMatrix();
    }

    public CvKalmanFilter setMeasurementMatrix(final Mat measurementMatrix) {
        if(notAllowSet(getMeasurementMatrix(), measurementMatrix))
            throw new ArithmeticException("Cannot set measurement: wrong size.");
        super.set_measurementMatrix(measurementMatrix);
        return this;
    }

    @Override
    public CvMat get_processNoiseCov() {
        return CvMat.move(super.get_processNoiseCov());
    }

    /**
     * Process noise covariance matrix (Q).
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getProcessNoiseCovariance() {
        return this.get_processNoiseCov();
    }

    public CvKalmanFilter setProcessNoiseCovariance(final Mat processNoiseCov) {
        if(notAllowSet(getProcessNoiseCovariance(), processNoiseCov))
            throw new ArithmeticException("Cannot set process noise covariance: wrong size.");
        super.set_processNoiseCov(processNoiseCov);
        return this;
    }

    @Override
    public CvMat get_measurementNoiseCov() {
        return CvMat.move(super.get_measurementNoiseCov());
    }

    /**
     * Measurement noise covariance matrix (R)
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getMeasurementNoiseCovariance() {
        return this.get_measurementNoiseCov();
    }

    public CvKalmanFilter setMeasurementNoiseCovariance(final Mat measurementNoiseCovariance) {
        if(notAllowSet(getMeasurementNoiseCovariance(), measurementNoiseCovariance))
            throw new ArithmeticException("Cannot set measurement error covariance: wrong size.");
        super.set_measurementNoiseCov(measurementNoiseCovariance);
        return this;
    }

    @Override
    public CvMat get_errorCovPre() {
        return CvMat.move(super.get_errorCovPre());
    }

    /**
     * Priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getPrioriErrorEstimateCovariance() {
        return this.get_errorCovPre();
    }

    public CvKalmanFilter setPrioriErrorEstimateCovariance(final Mat errorCovPre) {
        if(notAllowSet(getPrioriErrorEstimateCovariance(), errorCovPre))
            throw new ArithmeticException("Cannot set priori error covariance: wrong size.");
        super.set_errorCovPre(errorCovPre);
        return this;
    }

    @Override
    public CvMat get_gain() {
        return CvMat.move(super.get_gain());
    }

    /**
     * Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getGain() {
        return this.get_gain();
    }

    public CvKalmanFilter setGain(final Mat gain) {
        if(notAllowSet(getGain(), gain))
            throw new ArithmeticException("Cannot set Kalman gain: wrong size.");
        super.set_gain(gain);
        return this;
    }

    @Override
    public CvMat get_errorCovPost() {
        return CvMat.move(super.get_errorCovPost());
    }

    /**
     * Posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)
     *
     * @return a shallow copied Mat to be managed by the caller.
     */
    public CvMat getPosterioriErrorEstimateCovariance() {
        return this.get_measurementNoiseCov();
    }

    public CvKalmanFilter setPosterioriErrorEstimateCovariance(final Mat errorCovPost) {
        if(notAllowSet(getPosterioriErrorEstimateCovariance(), errorCovPost))
            throw new ArithmeticException("Cannot set posteriori error covariance: wrong size.");
        super.set_errorCovPost(errorCovPost);
        return this;
    }

    protected void doNativeDelete() {
        try {
            nativeDelete.invoke(this, super.nativeObj);
        } catch(final IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
            throw new RuntimeException("Got an exception trying to call " + KalmanFilter.class.getSimpleName() + ".delete. Either the security model is too " +
                "restrictive or the version of OpenCV can't be supported.", e);
        }
    }

    public CvKalmanFilter skipOnceForReturn() {
        skipOnceForDelete = true;
        return this;
    }

    @Override
    public void close() {
        if(!skipOnceForDelete) {
            if(!deletedAlready) {
                doNativeDelete();
                deletedAlready = true;
                if(TRACK_MEMORY_LEAKS)
                    deleteTrace = new RuntimeException("Here's where I was closed.");
            } else if(TRACK_MEMORY_LEAKS) {
                LOGGER.warn("TRACKING: Deleting {} again at:", this.getClass()
                    .getSimpleName(), new RuntimeException());
                LOGGER.warn("TRACKING: Originally closed at:", deleteTrace);
                LOGGER.warn("TRACKING: Created at:", initTrace);
            }
        } else {
            skipOnceForDelete = false;
        }
    }

    @Override
    public void finalize() {
        if(!deletedAlready) {
            LOGGER.debug("Finalizing a {} that hasn't been closed.", this.getClass()
                .getSimpleName());

            if(TRACK_MEMORY_LEAKS)
                LOGGER.debug("TRACKING: Here's where I was instantiated: ", initTrace);
            close();
        }
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", CvKalmanFilter.class.getSimpleName() + "[", "]").add("dataType=" + dataType)
            .add("dynamicParameters=" + dynamicParameters)
            .add("measureParameters=" + measureParameters)
            .add("controlParameters=" + controlParameters)
            .add("deletedAlready=" + deletedAlready)
            .add("nativeObj=" + nativeObj)
            .toString();
    }

    /**
     * OpenCV's JNI wrappers do no error checking since the set methods directly assign to the underlying kalman.cpp's state. Rather than getting an illegal
     * argument exception, a runtime error is potentially, eventually returned instead. This preempts that problem by doing error checking at set time.
     */
    private static boolean notAllowSet(final CvMat original, final Mat newMat) {
        try(original) {
            return original.rows() != newMat.rows() || original.cols() != newMat.cols() || original.channels() != newMat.channels();
        }
    }

    /**
     * This is a convenience method for {@link CvKalmanFilter#dump(CvKalmanFilter, PrintStream)} that uses {@link System#out} as the {@link PrintStream} and
     * dumps all elements of every mat in the supplied filter.
     * <p>
     * This is an expensive operation.
     */
    public static void dump(final CvKalmanFilter filter) {
        dump(filter, System.out);
    }

    /**
     * Dumps elements of every mat in the supplied filter to the supplied print stream.
     * <p>
     * This is an expensive operation.
     */
    public static void dump(final CvKalmanFilter filter, final PrintStream out) {
        out.println(filter.toString());
        if(filter.deletedAlready)
            return;

        try(Closer c = new Closer();) {
            dumpMat("Predicted state (x'(k))", c.add(filter.getPredictionState()), out);
            dumpMat("Corrected state (x(k))", c.add(filter.getCorrectedState()), out);
            dumpMat("Transition matrix (A)", c.add(filter.getTransitionMatrix()), out);
            dumpMat("Control matrix (B)", c.add(filter.getControlMatrix()), out);
            dumpMat("Measurement matrix (H)", c.add(filter.getMeasurementMatrix()), out);
            dumpMat("Kalman gain (K)", c.add(filter.getGain()), out);
            dumpMat("Process noise uncertainty/cov (Q)", c.add(filter.getProcessNoiseCovariance()), out);
            dumpMat("Measurement noise uncertainty/cov (R)", c.add(filter.getMeasurementNoiseCovariance()), out);
            dumpMat("Priori error estimate uncertainty/cov (P'(k))", c.add(filter.getPrioriErrorEstimateCovariance()), out);
            dumpMat("Posteriori error estimate uncertainty/cov (P(k))", c.add(filter.getPosterioriErrorEstimateCovariance()), out);
        }
    }

    private static void dumpMat(final String name, final CvMat mat, final PrintStream out) {
        try(mat) {
            out.print("- " + name + ": ");
            if(mat == null || mat.cols() == 0) {
                out.println("[]");
            } else {
                Utils.dump(mat, out);
            }
        }
    }
}
